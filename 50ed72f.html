<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/webicon-32x32-house.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/webicon-16x16-house.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-loading-bar.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"harpersu00.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"Available values":"default | flat | mac","style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="翻译自 Jonathan Levin’s site   原文链接：http:&#x2F;&#x2F;newosxbook.com&#x2F;articles&#x2F;MemoryPressure.html  AboutOS X 和 iOS 中的内存压力是虚拟内存管理的一个非常重要的方面，在我的书中[1]已经有了一些介绍。 我提到的 Jetsam&#x2F;memorystatus 机制，已经随着时间的推移发生了重大变化，最终形成了最近在 Ma">
<meta property="og:type" content="article">
<meta property="og:title" content="（译）Handling low memory conditions in iOS and Mavericks">
<meta property="og:url" content="https://harpersu00.github.io/50ed72f.html">
<meta property="og:site_name" content="harpersu00&#39;s Blog">
<meta property="og:description" content="翻译自 Jonathan Levin’s site   原文链接：http:&#x2F;&#x2F;newosxbook.com&#x2F;articles&#x2F;MemoryPressure.html  AboutOS X 和 iOS 中的内存压力是虚拟内存管理的一个非常重要的方面，在我的书中[1]已经有了一些介绍。 我提到的 Jetsam&#x2F;memorystatus 机制，已经随着时间的推移发生了重大变化，最终形成了最近在 Ma">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://harpersu00.github.io/images/2017-05-09-%E8%AF%91-Handling-low-memory-conditions-in-iOS-and-Mavericks/%E5%9B%BE%E7%89%871.png">
<meta property="og:image" content="https://harpersu00.github.io/images/2017-05-09-%E8%AF%91-Handling-low-memory-conditions-in-iOS-and-Mavericks/%E5%9B%BE%E7%89%872.png">
<meta property="og:image" content="https://harpersu00.github.io/images/2017-05-09-%E8%AF%91-Handling-low-memory-conditions-in-iOS-and-Mavericks/%E5%9B%BE%E7%89%873.png">
<meta property="og:image" content="https://harpersu00.github.io/images/2017-05-09-%E8%AF%91-Handling-low-memory-conditions-in-iOS-and-Mavericks/%E5%9B%BE%E7%89%874.png">
<meta property="og:image" content="https://harpersu00.github.io/images/2017-05-09-%E8%AF%91-Handling-low-memory-conditions-in-iOS-and-Mavericks/%E5%9B%BE%E7%89%875.png">
<meta property="og:image" content="https://harpersu00.github.io/images/2017-05-09-%E8%AF%91-Handling-low-memory-conditions-in-iOS-and-Mavericks/%E5%9B%BE%E7%89%876.png">
<meta property="og:image" content="https://harpersu00.github.io/images/2017-05-09-%E8%AF%91-Handling-low-memory-conditions-in-iOS-and-Mavericks/%E5%9B%BE%E7%89%877.png">
<meta property="og:image" content="https://harpersu00.github.io/images/2017-05-09-%E8%AF%91-Handling-low-memory-conditions-in-iOS-and-Mavericks/%E5%9B%BE%E7%89%878.png">
<meta property="og:image" content="https://harpersu00.github.io/images/2017-05-09-%E8%AF%91-Handling-low-memory-conditions-in-iOS-and-Mavericks/%E5%9B%BE%E7%89%879.png">
<meta property="article:published_time" content="2017-05-08T16:00:00.000Z">
<meta property="article:modified_time" content="2020-10-16T01:40:53.347Z">
<meta property="article:author" content="harpersu00">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://harpersu00.github.io/images/2017-05-09-%E8%AF%91-Handling-low-memory-conditions-in-iOS-and-Mavericks/%E5%9B%BE%E7%89%871.png">

<link rel="canonical" href="https://harpersu00.github.io/50ed72f.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>（译）Handling low memory conditions in iOS and Mavericks | harpersu00's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">harpersu00's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-book fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fas fa-list fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://harpersu00.github.io/50ed72f.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.JPG">
      <meta itemprop="name" content="harpersu00">
      <meta itemprop="description" content="记录，记录一下ing">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="harpersu00's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          （译）Handling low memory conditions in iOS and Mavericks
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-05-09 00:00:00" itemprop="dateCreated datePublished" datetime="2017-05-09T00:00:00+08:00">2017-05-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BF%BB%E8%AF%91/" itemprop="url" rel="index"><span itemprop="name">翻译</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>翻译自 Jonathan Levin’s site   原文链接：<a target="_blank" rel="noopener" href="http://newosxbook.com/articles/MemoryPressure.html">http://newosxbook.com/articles/MemoryPressure.html</a></p>
</blockquote>
<h2 id="About"><a href="#About" class="headerlink" title="About"></a>About</h2><p>OS X 和 iOS 中的内存压力是虚拟内存管理的一个非常重要的方面，在我的书中[<a target="_blank" rel="noopener" href="https://amywushu.github.io/2017/05/09/%E8%AF%91-Handling-low-memory-conditions-in-iOS-and-Mavericks.html#references">1]</a>已经有了一些介绍。 我提到的 Jetsam/memorystatus 机制，已经随着时间的推移发生了重大变化，最终形成了最近在 Mavericks 中引入的一些非常重要的系统机制和系统调用。 在使用我的 OS X 和 iOS 的Process Explorer 时，我遇到了这些新增加的问题，因此在这里记录。 这是作为本书第12章的补充，当然也可以单独阅读。</p>
<a id="more"></a>

<h3 id="Why-should-you-care-Target-Audience"><a href="#Why-should-you-care-Target-Audience" class="headerlink" title="Why should you care? (Target Audience)"></a>Why should you care? (Target Audience)</h3><p>物理内存（RAM），是 CPU 的另一个方面，也是系统中最稀少的资源，是最有可能导致竞争的资源，因此 apps 争夺每一个有效的 bit。应用程序的内存与性能直接相关 - 通常是以别人的为代价。 在 iOS 中，没有能够交换内存的交换空间，这使得内存资源更为重要。 本文旨在让您下次调用 malloc() 或 mmap() 之前再三考虑，以及阐明 iOS 上最常见的崩溃原因 -低系统内存的原因。</p>
<h2 id="Prerequisite-Virtual-Memory-in-a-nutshell"><a href="#Prerequisite-Virtual-Memory-in-a-nutshell" class="headerlink" title="Prerequisite: Virtual Memory in a nutshell"></a>Prerequisite: Virtual Memory in a nutshell</h2><p>无论一个应用程序是如何编程的，它都必须在内存空间中运行。 这个空间是一个应用程序可以控制自己的代码，数据和状态的地方。 当然，如果这样一个空间与其他应用程序隔离，这是非常有益的，因为提供了更好的安全性和稳定性。 我们将这个空间称为应用程序的虚拟内存，它是应用程序的一个定义特性之一：应用程序的所有线程将共享相同的虚拟内存空间，也因此被定义为处于同一进程。</p>
<p>虚拟内存中的术语“虚拟”意味着存储器空间虽然与所讨论的进程有很大关系，但并不完全对应于系统里的实际内存。 这表现在几个方面：</p>
<ul>
<li>虚拟内存空间可以超过可用的实际内存量 - 取决于所讨论的处理器字大小和操作系统，虚拟内存空间可高达4GB（32位）或256TB（64位）[<a target="_blank" rel="noopener" href="https://amywushu.github.io/2017/05/09/%E8%AF%91-Handling-low-memory-conditions-in-iOS-and-Mavericks.html#footnotes">1]</a>。这，尤其在后一种情况下，可以远远超出现有的可用内存量。</li>
<li>实际上，虚拟内存并不存在：给出如此巨大的超过物理内存支持能力的内存空间，只有当应用程序明确请求内存（即分配），系统才会为支持的虚拟内存映射物理内存。因此，一个进程的虚拟内存的影像是非常稀疏的，在内存中就像在一片浩瀚的虚空海洋中的“孤岛”。</li>
<li>即使分配了，虚拟内存可能仍然是虚拟的： - 当你调用malloc(3) 时，并不意味着系统会跳转并找到相应数量的RAM来实质地分配你的内存。大多数情况下，程序员的分配远远超过他们所需要的。因此，malloc(3) 操作，只分配页表入口（entries），很少分配内存本身。实际上，当访问内存时（比如说 memset(3)），才会导致物理分配。</li>
<li>系统可以备份内存到磁盘或网络上 - 也称为“交换”内存到后台存储。 OS X 一般使用交换文件（在/var/vm中）。iOS没有交换机制。</li>
<li>您使用的虚拟内存可能共享或不共享 - 操作系统保留使用与其他进程隐式共享你的虚拟内存的权限。这适用于使用文件备份的内存（即通过调用 mmap(2) 声明的内存）。如果你的进程和另一个进程 mmap(2) 相同的文件，操作系统可以给你们每个进程一份你的私有虚拟副本，但实际上是同一个物理副本。上述物理副本将被标记为不可写。只要每个进程都只是从内存中读取，那么一份就足够了。然而，如果任何人向这样的隐式共享内存写入，写入过程将触发页面错误，这将导致内核执行一个 Copy-On-Write 机制（COW），从而产生一个可以修改内容的新物理副本。</li>
</ul>
<p>把上面总结一下，我们可以得到以下“公式”：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  VSS = RSS + LSS + SwSS  </span><br><span class="line">各项含义：   </span><br><span class="line">VSS　　虚拟大小，由top，ps(<span class="number">1</span>) 和其他的命令可以看到   </span><br><span class="line">RSS　　驻留大小 - 进程的实际RAM占用空间。 也可以在 top(<span class="number">1</span>)，ps(<span class="number">1</span>) 等中显示   </span><br><span class="line">LSS 　　“Lazy” 大小 - 系统同意分配但尚未分配的内存   </span><br><span class="line">SwSS　　“交换”大小 - 以前在RAM中但被推出交换的内存。在 iOS 中，一直为<span class="number">0</span>　　　　</span><br></pre></td></tr></table></figure>

<p>以上所有的东西可以通过一个简单的例子清楚地展示 - 在任一进程中使用 vmmap(1)，这里以 shell 本身为例：</p>
<p><img src="/images/2017-05-09-%E8%AF%91-Handling-low-memory-conditions-in-iOS-and-Mavericks/%E5%9B%BE%E7%89%871.png"></p>
<p><img src="/images/2017-05-09-%E8%AF%91-Handling-low-memory-conditions-in-iOS-and-Mavericks/%E5%9B%BE%E7%89%872.png"></p>
<p><strong>术语</strong><br>在本文中，使用以下术语：</p>
<ul>
<li>Page - 内存管理的基本单元。在 Intel 和 ARM 中，通常为4k（4096），在 ARM64 中通常为16K。您可以使用 OS X 上的 pagesize(1) 命令（或任何一个操作系统上的 sysctl hw.pagesize）来确定默认页面大小是多少。英特尔架构支持超级页面（8k）和巨大页面（2MB），但在实践中，这些页面相对较少。</li>
<li>Phsyical Memory/RAM - 安装在主机（Mac 或 i-Device）上的有限数量的内存。你可以使用 <code>hostinfo(1)</code> 命令获取这个值。</li>
<li>Virtual Memory - 由程序或系统本身分配的内存，通常是通过调用 <code>malloc(3)，mmap(2)</code> 或更高级别的调用（例如Objective-C 的 [alloc]等）分配。虚拟内存可能是私有的（由单个进程所有）或共享的（由2+进程所有）。共享内存可以是明确地或隐式地共享。</li>
<li>Page Fault - 当内存管理单元（MMU）检测到违规访问虚拟内存时，即发生以下情况之一：<ul>
<li>访问未分配的内存：取值一个之前未被分配的内存指针 - XNU将其转换为一个 EXC_BAD_ACCESS 异常，并且进程将接收到分段错误（SIGSEGV，Signal#11）。</li>
<li>访问已分配但未提交的内存：取值一个先前已分配但尚未使用的内存指针（或相应的madvise(2)） - XNU拦截，并意识到它不能再等待，必须分配物理页。当分配页面时，将冻结导致故障的线程。</li>
<li>访问内存但不符合其权限：内存页面以与标准 UNIX 文件权限相似的方式受 r/w/x 保护。尝试写入只读目标（r–或rx）将导致页面错误，XNU 将其转换为总线故障（SIGBUS，Signal#7）或强制执行 Copy-On-Write（COW）操作（如果是隐式共享的）。</li>
</ul>
</li>
</ul>
<p><strong>工具</strong><br>苹果提供了几个重要的工具来检查虚拟内存：</p>
<ul>
<li>vmmap(1) - 检查单个进程的虚拟内存，以类似于Linux 以 /proc/<pid>/maps 的方式布局其 “map”。</li>
<li>vm_stat(1) - 从系统范围的角度提供有关虚拟内存的统计信息。 这实际上只是一个调用 Mach host_statistics64 API 的封装器，打印出 vm_statistics64_t（来自&lt;mach/vm_statistics.h&gt;）。</li>
<li>top(1) - 提供与性能有关的全系统以及每个进程的统计信息。 在其中，MemRegions，PhysMem 和 VM 统计信息涉及虚拟内存。<br>我厚脸皮地在这里推广一下自己的工具，process explorer （procexp），它提供了（IMHO）比 top(1) 更好的功能（包括更丰富的内存统计）。</li>
</ul>
<h2 id="Memory-Pressure"><a href="#Memory-Pressure" class="headerlink" title="Memory Pressure"></a>Memory Pressure</h2><p>Mach 层内部有两个计数器定义内存压力：</p>
<ul>
<li>vm_page_free_count：目前有多少页 RAM 是空闲的</li>
<li>vm_page_free_target：至少有多少页 RAM 应该被释放。<br>你可以使用 sysctl 轻松查看这些：</li>
</ul>
<p><img src="/images/2017-05-09-%E8%AF%91-Handling-low-memory-conditions-in-iOS-and-Mavericks/%E5%9B%BE%E7%89%873.png"></p>
<p>如果空闲页面的数量低于目标数量 - 也就是有内存压力的情况（当然还有其他潜在的情况，但为了简化起见我省略了这些 [<a target="_blank" rel="noopener" href="https://amywushu.github.io/2017/05/09/%E8%AF%91-Handling-low-memory-conditions-in-iOS-and-Mavericks.html#footnotes">2]</a>）。你也可以使用 sysctl(8) 来查询 <code>vm.memory_pressure</code> 的值。在 OS X 10.9 及更高版本中，你也可以查询 <code>kern.memorystatus_vm_pressure_level</code>，其值为 1（NORMAL），2（WARN）或 4（CRITICAL）</p>
<p>在内核初始化之后，主线程变为 vm_pageout，并产生一个专用的线程，并被贴切地叫做 vm_pressure_thread，用来监测压力事件。这个线程是空转的（阻塞自己）。当检测到压力时，线程将被 vm_pageout 唤醒。这种行为已在 XNU 2422/3（OSX 10.9/iOS 7）中修改（最显著的是转移到了 vm_pressure_response 中封装）。</p>
<p>只有当 VM_PRESSURE_EVENTS 是 #define 的时候，压力处理才会被编译到 XNU 中。如果不是（比如，自定义编译），vm_pressure_thread 在2050 版本中什么都不做，甚至在 2422/3 中也不会开始。此外，在iOS内核中，定义 CONFIG_JETSAM 会更频繁地将内存处理调度到 memorystatus 线程以及更新其计数器（稍后会讲）来更改某些行为。</p>
<h3 id="mach-vm-pressure-monitor"><a href="#mach-vm-pressure-monitor" class="headerlink" title="[mach]_vm_pressure_monitor"></a>[mach]_vm_pressure_monitor</h3><p>XNU 导出未记录的系统调用#296，vm_pressure_monitor（bsd/vm/vm_unix.c），它是 mach_vm_pressure_monitor（osfmk/vm/vm_pageout.c）以上的一个封装器。系统调用（以及相应的内部 Mach 调用）定义如下：</p>
<blockquote>
<p>int vm_pressure_monitor（int wait_for_pressure，int nsecs_monitored，uint32_t * pages_reclaimed）;</p>
</blockquote>
<p>这个调用将立即返回或者阻塞（当 <code>wait_for_pressure</code> 不为零时）。它将返回 page_reclaimed 在 nsecs_monitored 的计数中释放了多少个物理页面（并不是真的循环迭代那么多的 nsecs）。其返回值表示需要提供多少页面（上面的sysctl(8) 输出中的 <code>vm.page_free_wanted</code>）。调用系统调用很简单，而且不需要 root 权限。 （再次重复，您也可以使用sysctl(8) 来查询 <code>vm.memory_pressure</code>，尽管这个操作不会等待内存压力）。</p>
<p>您可以使用 “vmmon” 参数运行 process explorer 来尝试这个系统调用（否则，process explorer 将在交互模式下在单独的线程中执行此操作，以显示压力警告）。指定 “oneshot” 的附加参数将会在不等待压力的情况下直接调用。否则，调用将等待，直到检测到压力：</p>
<p><img src="/images/2017-05-09-%E8%AF%91-Handling-low-memory-conditions-in-iOS-and-Mavericks/%E5%9B%BE%E7%89%874.png"></p>
<p>但是系统实际上是如何收回内存的？对于此，需要涉及到 memorystatus。</p>
<h2 id="MemoryStatus-and-Jetsam"><a href="#MemoryStatus-and-Jetsam" class="headerlink" title="MemoryStatus and Jetsam"></a>MemoryStatus and Jetsam</h2><p>当 XNU 移植到 iOS 时，苹果遇到了移动设备限制引起的重大挑战 - 没有交换空间。与桌面相比，虚拟内存可以“溢出”到外部存储器，在这里并不适用（主要是由于闪存的限制）。因此，内存已经成为一个更重要（更稀缺）的资源。</p>
<p>引入：MemoryStatus。最初在 iOS 中引入的这种机制是一个内核线程，负责处理低 RAM 事件，以 iOS 认为可能的唯一方式：丢弃（弹出）尽可能多的RAM，为应用程序释放内存 - 即使当这种方式意味着杀死应用程序。这就是 iOS 的 jetsam 机制，可以在 XNU 源代码中看到 <code>#if CONFIG_JETSAM</code> 编译选项。在 OS X 中，memorystatus 代表的不是 kill，而是那些标记为空闲退出的进程，这是一种更温和的方式，更适合于桌面环境[<a target="_blank" rel="noopener" href="https://amywushu.github.io/2017/05/09/%E8%AF%91-Handling-low-memory-conditions-in-iOS-and-Mavericks.html#footnotes">3]</a>。 使用 dmesg，以及 grep 可以看到 memorystatus 的操作：</p>
<p><img src="/images/2017-05-09-%E8%AF%91-Handling-low-memory-conditions-in-iOS-and-Mavericks/%E5%9B%BE%E7%89%875.png"></p>
<p>memorystatus 线程是一个单独的线程（也就是不直接与 vm_pressure_thread 相关），它在XNU的 BSD 部分启动（通过在 <code>bsd/kern/bsd_init.c</code> 中调用 <code>memorystatus_init</code>）。如果定义了 CONFIG_JETSAM（iOS），memorystatus 会启动另一个线程 <code>memorystatus_jetsam_thread</code>，它大部分时间在阻塞循环中运行，当memorystatus_available_pages &lt;= memorystatus_available_pages_critical 时被唤醒，杀死处于 memory list 中最上方的进程，然后再次阻塞。</p>
<p>在 iOS 中，memorystatus/jetsam 不会打印消息，但肯定会在 <code>/Library/Logs/CrashReporter/LowMemory-YYYY-MM-DD-hhmmss.plist</code> 中留下其杀死程序的痕迹 - 这些日志由 CrashReporter 生成，类似于包含了 dump 的崩溃日志。如果你有越狱设备，一个简单的方法可以强制 jetsam 大规模执行，运行一个小的二进制文件，不停的分配和 memset() 大小为8MB 的内存块（这个留给感兴趣的读者练习），然后运行它。你将会看到应用程序死亡，直到这个犯规的二进制文件（最终）被杀死。日志将看起来像这样：</p>
<p><img src="/images/2017-05-09-%E8%AF%91-Handling-low-memory-conditions-in-iOS-and-Mavericks/%E5%9B%BE%E7%89%876.png"></p>
<p><img src="/images/2017-05-09-%E8%AF%91-Handling-low-memory-conditions-in-iOS-and-Mavericks/%E5%9B%BE%E7%89%877.png"></p>
<p>（请注意，您可以在非越狱设备上执行此操作，如果您已将其配置为开发用，您可以在 Objective-C 中创建一个简单的 iOS 应用程序，并执行相同的分配，然后通过 XCode 的 Organizer 收集日志） 。</p>
<p>应该注意的是，Jetsam 无情地彻底杀死一个进程，并非罕见：Linux（以及它的继承者，Android）在 “OOM”（out-of-memory）killer 中有一个类似的机制，它持有了每个进程的（可能是可调整的）分数，当遇到内存不足时，杀死高分数进程。在桌面 Linux 中，OOM 在系统交换空间耗尽时唤醒；在 Android 中，要更早一点，当 RAM 运行内存较低时就被唤醒。Android 的方法是得分驱动（该分数实际上是一种启发式方法，取决于使用了多少 RAM，以及怎样的频率），而 iOS 的方法是基于优先级的。</p>
<p>从 XNU 2423 开始，Jetsam 使用了一种 “priority bands”（参见 &lt;sys/kern_memorystatus.h&gt; JETSAM_PRIORITY 常量），也就是说 jetsam 跟踪的进程被维护在内核空间（memstat_bucket）的21个链表的数组中。Jetsam 将选择最低优先级元（以0或 JETSAM_PRIORITY_IDLE 开头）的第一个进程，如果当前优先级为空（参考 memorystatus_get_first_proc_locked，在bsd/kern/kern_memorystatus.c 中），则顺移至下一个优先级列表。进程的默认优先级为18，允许 jetsam 选择空闲和后台进程，这些进程的顺序排在交互式和可能重要的进程之前。如下图所示：</p>
<p><img src="/images/2017-05-09-%E8%AF%91-Handling-low-memory-conditions-in-iOS-and-Mavericks/%E5%9B%BE%E7%89%878.png"></p>
<p>Jetsam 还有另一种操作方式，它设置进程内存的 “high water mark”，并且将彻底杀死超过其 HWM 的进程。 当一个任务的 RSS 内存超过系统范围限制时，Jetsam 中的 HWM 模式就会被触发（更准确地说，是任务的 phys_footprint 内存，其中包括 RSS，也包括 compressed 和 I/O Kit 相关的内存）。 HWM 可以通过 memorystatus_control 操作 #5（MEMORYSTATUS_CMD_SET_JETSAM_HIGH_WATER_MARK，稍后讨论）来设置 。</p>
<p>在 iOS 上，Launchd 可以设置 jetsam 的优先级。 之前这个操作是在每个守护进程的基础文件（也就是在它的 plist 文件）中完成的。 现在看来，这些设置已被移至 com.apple.jetsamproperties.<em>model</em>.plist（例如 N51(5s)，J71(iPad Air)等）。 如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>CachedDefaults<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Array of dict entries, with key being daemon name e.g. --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.usb.networking.addNetworkInterface<span class="tag">&lt;/<span class="name">key</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">key</span>&gt;</span>JetsamMemoryLimit<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">integer</span>&gt;</span>integer&gt;6<span class="tag">&lt;/<span class="name">integer</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">key</span>&gt;</span>JetsamPriority<span class="tag">&lt;/<span class="name">key</span>&gt;</span> </span><br><span class="line">                        <span class="tag">&lt;<span class="name">integer</span>&gt;</span>integer&gt;3<span class="tag">&lt;/<span class="name">integer</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">key</span>&gt;</span>WellBehaved<span class="tag">&lt;/<span class="name">key</span>&gt;</span> </span><br><span class="line">                        <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line">..</span><br></pre></td></tr></table></figure>

<p>由于 RAM 消耗而彻底杀死一个进程可能看起来过于苛刻，但对于缺乏交换机制的系统来说，实际上能做的非常少。在 Jetsam 杀死一个进程之前，memorystatus 允许进程“挽回自身”，避免不合适的终止，可以通过获取 memorystatus 线程首先向作为终止的“候选”进程发送一个 kernel note（又称 kevent） 。这个 knote（<code>NOTE_VM_PRESSURE，&lt;sys/event.h&gt;</code>）将被 EVFILT_VM kevent() 过滤器拾取，就像 UIKit 把它转换为 <code>didReceieveMemoryWarning</code> 通知一样，这无疑是 iOS App 开发人员所熟悉的（也被其讨厌）。Darwin 的 libC 和 GCD 也加入了内存压力处理程序，具体如下：</p>
<ul>
<li>Darwin 的 LibC（&lt;malloc/malloc.h&gt;）定义了一个 <code>malloc_zone_pressure_relief</code>（从 OSX 10.7/iOS 4.3 开始）</li>
<li>LibCache（&lt;cache.h&gt;）定义了缓存成本（对于 cache_set_and_retain），允许发生压力事件时自动清除缓存。</li>
<li>GCD（&lt;dispatch/source.h&gt;）定义了 <code>DISPATCH_SOURCE_TYPE_MEMORYPRESSURE</code>（从OSX 10.9 起）</li>
</ul>
<p>一般来说，注册了内存压力的应用程序（直接通过 Darwin API 或间接通过 UIKit）应该减少其缓存和潜在的不需要的内存（应该注意的是，遍历内存结构可能导致页面错误，会加剧内存压力）。 UIKit 是不开源的，但是当 UIApplication 遇到内存警告时，jtool 提供了一个很好的反汇编来演示它的行为：</p>
<p><img src="/images/2017-05-09-%E8%AF%91-Handling-low-memory-conditions-in-iOS-and-Mavericks/%E5%9B%BE%E7%89%879.png"></p>
<p>然而有时候，释放内存可能不足以缓解内存压力。 大多数情况下，释放的内存可能很快被另一个不愿意释放它的应用程序占用。 在这些情况下，最后的手段是杀死潜在候选人列表中最上方的进程 - 所以 Jetsam 出现了。</p>
<p><strong>Controlling memorystatus</strong></p>
<p>一个线程可以随意地决定杀死进程可能有点危险。因此，苹果使用几种API来“统治”Jetsam/memorystatus。当然，这些都是私有的和无文档记录的（如果在应用程序中使用它们，苹果可能会 kill 你的开发人员帐户），它们是：</p>
<ul>
<li>使用 sysctl kern.memorystatus_jetsam_change：可以从用户空间更改 Jetsam 的优先级列表。这有点像 Linux 的 oom_adj，它允许进程通过指定负调整数（有效地降低它们的分数）来逃避 OOM 的惩罚。同样，在 iOS 中，launchd（启动所有应用程序的进程）可以设置 Jetsam 优先级列表。 （例如，参考 com.apple.voiced.plist，它指定 JetSamMemoryLimit(8000) 和 JetsamPriority(-49) ），sysctl 内部调用memorystatus_list_change（在 bsd/kern/kern_memorystatus.c 中），它会再次设置优先级和状态标志（active，foreground 等）。 - 跟 Linux 类似，在这种情况下，Android的处理机制是 “Low Memory Killer”（在运行时可以根据应用程序/活动的前台状态来调整 OOM_ADJ，因此更喜欢首先杀死后台应用程序）。这种方法可以运行到 iOS 6.x。</li>
<li>使用 memorystatus_control(#440) 系统调用：在 xnu 2107 某处（即早在 iOS 6 而不是直到 OS X 10.9）中介绍，这个（无文档记录的）系统调用能够通过使用几个“命令”之一，来控制 memorystatus 和 jetsam（后者在 iOS 上），如下表所示：</li>
</ul>
<table>
<thead>
<tr>
<th align="left"><strong>MEMORYSTATUS_CMD_ const</strong></th>
<th align="left"><strong>availability</strong></th>
<th align="left"><strong>usage</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">GET_PRIORITY_LIST (1)</td>
<td align="left">OS X 10.9, iOS 6+</td>
<td align="left">Get priority list - array of memorystatus_priority_entry from &lt;sys/kern_memorystatus.h&gt; Example code can be seen <a target="_blank" rel="noopener" href="http://newosxbook.com/src.jl?tree=listings&file=mslist.c">Here</a></td>
</tr>
<tr>
<td align="left">SET_PRIORITY_PROPERTIES (2)</td>
<td align="left">iOS only (or CONFIG_JETSAM)</td>
<td align="left">Update properties for a given proess</td>
</tr>
<tr>
<td align="left">GET_JETSAM_SNAPSHOT (3)</td>
<td align="left">iOS only (or CONFIG_JETSAM)</td>
<td align="left">Get Jetsam snapshot - array of memorystatus_jetsam_snapshot_t entries (from &lt;sys/kern_memorystatus.h&gt;</td>
</tr>
<tr>
<td align="left">GET_PRESSURE_STATUS (4)</td>
<td align="left">iOS (or CONFIG_JETSAM)</td>
<td align="left">Privileged call: returns 1 if memorystatus_vm_pressure_level is not normal</td>
</tr>
<tr>
<td align="left">SET_JETSAM_HIGH_WATER_MARK (5)</td>
<td align="left">iOS (or CONFIG_JETSAM)</td>
<td align="left">Sets the maximum memory utilization for a given PID, after which it may be killed. Used by launchd for processes with a memory limit）</td>
</tr>
<tr>
<td align="left">SET_JETSAM_TASK_LIMIT (6)</td>
<td align="left">iOS 8 (or CONFIG_JETSAM)</td>
<td align="left">Sets the maximum memory utilization for a given PID, after which it <strong>will</strong> be killed. Used by launchd for processes with a memory limit</td>
</tr>
<tr>
<td align="left">SET_MEMLIMIT_PROPERTIES (7)</td>
<td align="left">iOS 9 (or CONFIG_JETSAM)</td>
<td align="left">Sets memory limits + attributes</td>
</tr>
<tr>
<td align="left">GET_MEMLIMIT_PROPERTIES (8)</td>
<td align="left">iOS 9 (or CONFIG_JETSAM)</td>
<td align="left">Retrieves memory limits + attributes</td>
</tr>
<tr>
<td align="left">PRIVILEGED_LISTENER_ENABLE (9)</td>
<td align="left">Xnu-3247 (10.11, iOS 9)</td>
<td align="left">Registers self to receive memory notifications</td>
</tr>
<tr>
<td align="left">PRIVILEGED_LISTENER_DISABLE (10)</td>
<td align="left">Xnu-3247 (10.11, iOS 9)</td>
<td align="left">Stops self receiving memory notifications</td>
</tr>
<tr>
<td align="left">TEST_JETSAM (1000)</td>
<td align="left">CONFIG_JETSAM &amp;&amp; (DEVELOPMENT 或 DEBUG)</td>
<td align="left">Test Jetsam, kill specific processes (Debug/Development kernels only)</td>
</tr>
<tr>
<td align="left">TEST_JETSAM_SORT (1001)</td>
<td align="left">iOS 9 &amp;&amp; (DEVELOPMENT 或 DEBUG)</td>
<td align="left">Test Jetsam sorting (Debug/Development kernels only)</td>
</tr>
<tr>
<td align="left">SET_JETSAM_PANIC_BITS (1001/1002)</td>
<td align="left">CONFIG_JETSAM &amp;&amp; (DEVELOPMENT 或 DEBUG)</td>
<td align="left">Alter Jetsam’s panic settings (Debug/Development kernels only)</td>
</tr>
</tbody></table>
<ul>
<li>使用 posix_spawnattr_setjetsam：来自于 posix_spawnattr 系列的函数，但是没有被记录，仅存在于 iOS 上（这就是 iOS 7 上 launchd 如何处理 Jetsam 的）</li>
<li>使用 sysctl kern.memorypressure_manual_trigger 用于模拟内存压力水平，而不会实际占用内存 - 由 OS X 10.9 的 memory_pressure 实用工具(-S) 使用。 来自&lt;sys/event.h &gt;，NOTE_MEMORYSTATUS_PRESSURE_ [NORMAL | WARN | CRITICAL] 的值。</li>
</ul>
<p><strong>Other memorystatus configurable values:</strong></p>
<ul>
<li>使用 sysctl kern.memorystatus_purge_on_ * 的值（OS X）。这些值不会像 pageout 守护程序那样影响 memorystatus，而是强制它清除warning(2)，urgent(5) 或critica(8) 的值。 将这些值设置为0将清除禁用。</li>
<li>使用 memorystatus_get_level(#453)：该系统调用返回（到 int *）一个介于0到100之间的数字，指定可用内存的百分比。 只是诊断。使用在 Activity Monitor（和我的 Process Explorer）上，以显示 Mavericks 以及之后的版本的内存压力。</li>
</ul>
<p><strong>Ledgers</strong></p>
<p>iOS 在 iOS 5（或5.1？）上重新引入了 ledgers，这个概念也被移植到了 OS X。 我说“重新引入”，是因为这是从开始的 Mach 设计以来， ledgers 已经存在，只是那时还没有真正实现。</p>
<p>ledgers 有助于解决资源利用率过多的问题。 与经典的 UN * X 模型不同（setrlimit(2)，被用户所熟知的 ulimit(1) ），ledgers 具有更细粒度的类似于 QoS 的模型，ledgers 为每个资源的每个时间单位分配一定的配额（RAM，CPU，I/O ），并且以奇怪的方式 “refills”。这允许操作系统提供 leaky-bucket 类型的 QoS 机制，并保证服务水平，如果一个进程超过它的 ledgers ，则会产生一个 Mach 异常（EXC_RESOURCE，#12，如果是内存服务的话）。</p>
<p>今后，苹果将完全转向基于 ledgers 的 RAM 管理机制，这是非常有意义的，尤其是在 iOS 这样一个资源稀缺（并且没有交换机制）的情况下。 Jetsam 将可能会被保留作为最后的手段。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References:"></a>References:</h2><ol>
<li><a target="_blank" rel="noopener" href="http://newosxbook.com/articles/...">Mac OS X and iOS Internals, J Levin</a></li>
</ol>
<h2 id="ChangeLog"><a href="#ChangeLog" class="headerlink" title="ChangeLog"></a>ChangeLog</h2><ul>
<li>3/1/2014 - Added jetsam properties plist from iPhone5s, and note about ledgers</li>
<li>2/10/2016 - Added jetsam/memorystatus commands for xnu 32xx (iOS 9, OS X 10.11). Also updated procexp to show mem limits on iOS</li>
</ul>
<h2 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h2><ol>
<li>为了简单阐述，我们忽略了为某些给定进程提供的虚拟内存，实际上只是保留和映射以供内核使用的事实。顺便说一句，对于64位来说，是256TB，是由于硬件限制（加上没有人会真正使用它，更不用说是全64位的16EB）。 Mac OS X 以128-TB的47位（0x7fffffffffff）用做用户空间虚拟内存，最上面的（技术上为 0xffffffff8 …）128TB 为内核保留。</li>
<li>再次声明，为了简化，我并没有说明实际的条件。</li>
<li>我没有考虑空闲降级的过程，也就是说（10.9）进程可能被移动到空闲频段，以便它们成为空闲退出的候选者。 进程可以使用 PROC_INFO_CALL_DIRTYCONTROL 调用 proc_info 让内核跟踪其状态，当“dirty”和“clean”（空闲）自愿允许被杀死时，寻求保护以免被 kill 。与 vproc 机制（&lt;vproc.h&gt;）一起使用。</li>
</ol>

    </div>

    
    
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:16px;">----------------------END <i class="far fa-smile-wink"></i> END----------------------</div>
    
</div>
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>harpersu00
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://harpersu00.github.io/50ed72f.html" title="（译）Handling low memory conditions in iOS and Mavericks">https://harpersu00.github.io/50ed72f.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/ebd19f03.html" rel="prev" title="Objective-C 中的类结构">
      <i class="fa fa-chevron-left"></i> Objective-C 中的类结构
    </a></div>
      <div class="post-nav-item">
    <a href="/1e59798b.html" rel="next" title="GOT 表劫持原理">
      GOT 表劫持原理 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  
  <div class="comments">
  <script src="https://utteranc.es/client.js" repo="harpersu00/ForBlogComments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>
  </div>
  
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#About"><span class="nav-number">1.</span> <span class="nav-text">About</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Why-should-you-care-Target-Audience"><span class="nav-number">1.1.</span> <span class="nav-text">Why should you care? (Target Audience)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Prerequisite-Virtual-Memory-in-a-nutshell"><span class="nav-number">2.</span> <span class="nav-text">Prerequisite: Virtual Memory in a nutshell</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Memory-Pressure"><span class="nav-number">3.</span> <span class="nav-text">Memory Pressure</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mach-vm-pressure-monitor"><span class="nav-number">3.1.</span> <span class="nav-text">[mach]_vm_pressure_monitor</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MemoryStatus-and-Jetsam"><span class="nav-number">4.</span> <span class="nav-text">MemoryStatus and Jetsam</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#References"><span class="nav-number">5.</span> <span class="nav-text">References:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ChangeLog"><span class="nav-number">6.</span> <span class="nav-text">ChangeLog</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Footnotes"><span class="nav-number">7.</span> <span class="nav-text">Footnotes</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="harpersu00"
      src="/images/avatar1.JPG">
  <p class="site-author-name" itemprop="name">harpersu00</p>
  <div class="site-description" itemprop="description">记录，记录一下ing</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/harpersu00" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;harpersu00" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:harpersu00@gmail.com" title="E-Mail → mailto:harpersu00@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
      
      <!-- 添加近期文章 -->
      
        <div class="links-of-blogroll motion-element links-of-blogroll-block">
        <div class="links-of-blogroll-title">
          <!-- modify icon to fire by szw -->
          <i class="fa fa-history fa-" aria-hidden="true"></i>
          近期文章
        </div>
        <ul class="links-of-blogroll-list">
          
          
            <li class='pull-left' style="white-space:wrap" align="left" >
                <time title="创建时间" itemprop="dateCreated datePublished" datetime="2019-01-08T00:00:00+08:00">
                  &emsp;01-08
                </time>
                <a href="/adec3bdf.html" title="栈溢出之 shellcode">栈溢出之 shellcode</a>
                <br>
            </li>
          
            <li class='pull-left' style="white-space:wrap" align="left" >
                <time title="创建时间" itemprop="dateCreated datePublished" datetime="2018-09-19T00:00:00+08:00">
                  &emsp;09-19
                </time>
                <a href="/1e59798b.html" title="GOT 表劫持原理">GOT 表劫持原理</a>
                <br>
            </li>
          
            <li class='pull-left' style="white-space:wrap" align="left" >
                <time title="创建时间" itemprop="dateCreated datePublished" datetime="2017-05-09T00:00:00+08:00">
                  &emsp;05-09
                </time>
                <a href="/50ed72f.html" title="（译）Handling low memory conditions in iOS and Mavericks">（译）Handling low memory conditions in iOS and Mavericks</a>
                <br>
            </li>
          
            <li class='pull-left' style="white-space:wrap" align="left" >
                <time title="创建时间" itemprop="dateCreated datePublished" datetime="2017-04-12T00:00:00+08:00">
                  &emsp;04-12
                </time>
                <a href="/ebd19f03.html" title="Objective-C 中的类结构">Objective-C 中的类结构</a>
                <br>
            </li>
          
            <li class='pull-left' style="white-space:wrap" align="left" >
                <time title="创建时间" itemprop="dateCreated datePublished" datetime="2017-03-23T00:00:00+08:00">
                  &emsp;03-23
                </time>
                <a href="/9acae560.html" title="Hook 原理之 CydiaSubstrate（二）：MSHookMessageEx">Hook 原理之 CydiaSubstrate（二）：MSHookMessageEx</a>
                <br>
            </li>
          
        </ul>
        </div>
      
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">harpersu00</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
